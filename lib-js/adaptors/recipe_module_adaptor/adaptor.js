// Generated by CoffeeScript 1.3.3
(function() {
  var CB_SUCCESS, FILE_ENCODING, JS_EXT, LOG_PREFIX, NODE_PATH, RECIPE, TMP_BUILD_DIR_SUFFIX, and_, apply2, async, events, exec, extend, fb, fork, fs, get_mtime, get_paths, get_target_fn, green, has_ext, is_array, is_dir, is_file, logger, maybe_build, newer, newest, partial, path, red, spawn, walk, yellow, _, _ref, _ref1, _ref2,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  _ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn, fork = _ref.fork;

  _ref1 = require('../../lib/utils'), maybe_build = _ref1.maybe_build, is_dir = _ref1.is_dir, is_file = _ref1.is_file, has_ext = _ref1.has_ext, and_ = _ref1.and_, get_mtime = _ref1.get_mtime, newer = _ref1.newer, walk = _ref1.walk, newest = _ref1.newest, extend = _ref1.extend, is_array = _ref1.is_array;

  LOG_PREFIX = 'UI/RecipeModule>';

  logger = (require('../../lib/logger'))(LOG_PREFIX);

  green = logger.green, yellow = logger.yellow, red = logger.red;

  async = require('async');

  events = require('events');

  _ = require('underscore');

  _ref2 = require('../../defs'), FILE_ENCODING = _ref2.FILE_ENCODING, TMP_BUILD_DIR_SUFFIX = _ref2.TMP_BUILD_DIR_SUFFIX, JS_EXT = _ref2.JS_EXT, NODE_PATH = _ref2.NODE_PATH, CB_SUCCESS = _ref2.CB_SUCCESS, RECIPE = _ref2.RECIPE;

  apply2 = function(type, color) {
    return function(a) {
      var msg, prefix;
      prefix = color ? [color(LOG_PREFIX)] : [];
      msg = prefix.concat((is_array(a) ? a : [a]));
      return console[type].apply(console, msg);
    };
  };

  fb = {
    say: apply2('log', green),
    shout: apply2('info', yellow),
    scream: apply2('error', red),
    whisper: apply2('error', red),
    murmur: apply2('log')
  };

  partial = function() {
    var args, fn;
    fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return _.bind.apply(_, [fn, null].concat(__slice.call(args)));
  };

  get_target_fn = function(js_path, app_root, target_fn) {
    if (js_path) {
      return path.resolve(js_path, target_fn);
    } else {
      return path.resolve(app_root, TMP_BUILD_DIR_SUFFIX, target_fn);
    }
  };

  get_paths = function(ctx) {
    var app_root, js_path, mod_src, module_name, recipe, src, target_fn, target_full_fn, tmp_build_root;
    app_root = path.resolve(ctx.own_args.app_root);
    module_name = ctx.own_args.mod_name;
    src = ctx.own_args.src;
    js_path = ctx.own_args.js_path;
    mod_src = src || path.resolve(app_root, module_name);
    recipe = path.resolve(mod_src, RECIPE);
    target_fn = path.basename(module_name + JS_EXT);
    target_full_fn = get_target_fn(js_path, app_root, target_fn);
    tmp_build_root = js_path || path.resolve(app_root, TMP_BUILD_DIR_SUFFIX);
    return {
      mod_src: mod_src,
      recipe: recipe,
      target_fn: target_fn,
      target_full_fn: target_full_fn,
      tmp_build_root: tmp_build_root
    };
  };

  module.exports = (function() {
    var make_adaptor, match;
    match = function(ctx) {
      var mod_src, recipe, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, recipe = _ref3.recipe;
      return (is_dir(mod_src)) && (is_file(recipe));
    };
    match.async = function(ctx, cb) {
      var mod_src, recipe, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, recipe = _ref3.recipe;
      return async.parallel([
        (function(is_dir_cb) {
          return is_dir.async(mod_src, is_dir_cb);
        }), (function(is_file_cb) {
          return is_file.async(recipe, is_file_cb);
        })
      ], function(err, res) {
        if (!err && (and_.apply(null, res))) {
          return cb(CB_SUCCESS, true);
        } else {
          return cb(CB_SUCCESS, false);
        }
      });
    };
    make_adaptor = function(ctx) {
      var get_deps, harvest, last_modified, type;
      type = 'recipe';
      get_deps = function(recipe_deps, cb) {
        var deps, group, group_deps, module_name;
        module_name = ctx.own_args.mod_name;
        for (group in recipe_deps) {
          deps = recipe_deps[group];
          if (group === module_name) {
            group_deps = deps.concat();
          }
        }
        return cb(CB_SUCCESS, group_deps || []);
      };
      harvest = function(harvest_cb, opts) {
        var check_maybe_do, do_recipe, done, mod_src, target_fn, target_full_fn, tmp_build_root, _ref3;
        if (opts == null) {
          opts = {};
        }
        _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, target_full_fn = _ref3.target_full_fn, target_fn = _ref3.target_fn, tmp_build_root = _ref3.tmp_build_root;
        check_maybe_do = function(cb) {
          return maybe_build(mod_src, target_full_fn, function(changed, filename) {
            if (changed || (extend(ctx, opts)).own_args.f) {
              return cb();
            } else {
              return cb('MAYBE_SKIP');
            }
          });
        };
        do_recipe = function(cb) {
          var argv, cafe_factory, emitter, exit_cb, go, ready;
          ctx.fb.say("Harvesting recipe module");
          emitter = new events.EventEmitter;
          cafe_factory = require('../../cafe');
          ready = cafe_factory(emitter).ready;
          exit_cb = function(status_code, bundles) {
            return cb(null, bundles);
          };
          go = ready({
            exit_cb: exit_cb,
            fb: fb
          }).go;
          argv = {
            build: {
              app_root: mod_src,
              build_root: tmp_build_root,
              just_compile: true
            }
          };
          return go({
            args: argv
          });
        };
        done = function(err, res) {
          switch (err) {
            case null:
              ctx.fb.say("Recipe module " + mod_src + " was brewed");
              return harvest_cb(CB_SUCCESS, res);
            case "MAYBE_SKIP":
              ctx.fb.shout("maybe skipped");
              return harvest_cb(null, res);
            default:
              ctx.fb.scream("Error during compilation of recipe module " + mod_src + " err - " + err);
              return harvest_cb(err, res);
          }
        };
        return async.waterfall([check_maybe_do, do_recipe], done);
      };
      last_modified = function(cb) {
        var mod_src;
        mod_src = get_paths(ctx).mod_src;
        return walk(mod_src, function(err, results) {
          var max_time;
          if (results) {
            max_time = (function() {
              try {
                return newest(results.map(function(filename) {
                  return get_mtime(filename);
                }));
              } catch (ex) {
                return 0;
              }
            })();
            return cb(CB_SUCCESS, max_time);
          } else {
            return cb(CB_SUCCESS, 0);
          }
        });
      };
      return {
        type: type,
        get_deps: get_deps,
        harvest: harvest,
        last_modified: last_modified
      };
    };
    return {
      match: match,
      make_adaptor: make_adaptor
    };
  })();

}).call(this);
