// Generated by CoffeeScript 1.3.3
(function() {
  var CB_SUCCESS, FILE_ENCODING, JS_EXT, LEIN_ARGS, LEIN_BIN, NODE_PATH, PROJECT_CLJ, TMP_BUILD_DIR_SUFFIX, and_, async, cs, exec, extend, fs, get_mtime, get_paths, get_target_fn, has_ext, is_dir, is_file, maybe_build, newer, newest, path, say, scream, shout, walk, whisper, _ref, _ref1, _ref2;

  fs = require('fs');

  path = require('path');

  cs = require('coffee-script');

  exec = require('child_process').exec;

  _ref = (require('../lib/logger'))("Adaptor/Cakefile>"), say = _ref.say, shout = _ref.shout, scream = _ref.scream, whisper = _ref.whisper;

  _ref1 = require('../lib/utils'), maybe_build = _ref1.maybe_build, is_dir = _ref1.is_dir, is_file = _ref1.is_file, has_ext = _ref1.has_ext, and_ = _ref1.and_, get_mtime = _ref1.get_mtime, newer = _ref1.newer, walk = _ref1.walk, newest = _ref1.newest, extend = _ref1.extend;

  async = require('async');

  _ref2 = require('../defs'), FILE_ENCODING = _ref2.FILE_ENCODING, TMP_BUILD_DIR_SUFFIX = _ref2.TMP_BUILD_DIR_SUFFIX, JS_EXT = _ref2.JS_EXT, LEIN_BIN = _ref2.LEIN_BIN, NODE_PATH = _ref2.NODE_PATH, PROJECT_CLJ = _ref2.PROJECT_CLJ, CB_SUCCESS = _ref2.CB_SUCCESS, LEIN_ARGS = _ref2.LEIN_ARGS;

  get_target_fn = function(js_path, app_root, target_fn) {
    if (js_path) {
      return path.resolve(js_path, target_fn);
    } else {
      return path.resolve(app_root, TMP_BUILD_DIR_SUFFIX, target_fn);
    }
  };

  get_paths = function(ctx) {
    var app_root, js_path, mod_src, module_name, project_clj, src, target_fn, target_full_fn, tmp_build_root;
    app_root = path.resolve(ctx.own_args.app_root);
    module_name = ctx.own_args.mod_name;
    src = ctx.own_args.src;
    js_path = ctx.own_args.js_path;
    mod_src = src || path.resolve(app_root, module_name);
    project_clj = path.resolve(mod_src, PROJECT_CLJ);
    target_fn = path.basename(module_name + JS_EXT);
    target_full_fn = get_target_fn(js_path, app_root, target_fn);
    tmp_build_root = js_path || path.resolve(app_root, TMP_BUILD_DIR_SUFFIX);
    return {
      mod_src: mod_src,
      project_clj: project_clj,
      target_fn: target_fn,
      target_full_fn: target_full_fn,
      tmp_build_root: tmp_build_root
    };
  };

  module.exports = (function() {
    var make_adaptor, match;
    match = function(ctx) {
      var mod_src, project_clj, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, project_clj = _ref3.project_clj;
      return (is_dir(mod_src)) && (is_file(project_clj));
    };
    match.async = function(ctx, cb) {
      var mod_src, project_clj, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, project_clj = _ref3.project_clj;
      return async.parallel([
        (function(is_dir_cb) {
          return is_dir.async(mod_src, is_dir_cb);
        }), (function(is_file_cb) {
          return is_file.async(project_clj, is_file_cb);
        })
      ], function(err, res) {
        if (!err && (and_.apply(null, res))) {
          return cb(CB_SUCCESS, true);
        } else {
          return cb(CB_SUCCESS, false);
        }
      });
    };
    make_adaptor = function(ctx) {
      var get_deps, harvest, last_modified, type;
      type = 'clojurescript_lein_module';
      get_deps = function(recipe_deps, cb) {
        var deps, group, group_deps, module_name;
        module_name = ctx.own_args.mod_name;
        for (group in recipe_deps) {
          deps = recipe_deps[group];
          if (group === module_name) {
            group_deps = deps.concat();
          }
        }
        return cb(CB_SUCCESS, group_deps || []);
      };
      harvest = function(cb, opts) {
        var do_compile, mod_src, target_fn, target_full_fn, tmp_build_root, _ref3;
        if (opts == null) {
          opts = {};
        }
        _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, target_full_fn = _ref3.target_full_fn, target_fn = _ref3.target_fn, tmp_build_root = _ref3.tmp_build_root;
        do_compile = function(cb) {
          var args;
          args = [LEIN_BIN, LEIN_ARGS];
          opts = {
            cwd: mod_src,
            env: process.env
          };
          return exec(args.join(' '), opts, function(err, stdout, stderr) {
            if (err) {
              ctx.fb.scream("Error compiling " + mod_src + ": " + err);
              if (stdout) {
                ctx.fb.scream(("STDOUT: " + stdout).replace(/\n$/, ''));
              }
              if (stderr) {
                ctx.fb.scream(("STDERR: " + stderr).replace(/\n$/, ''));
              }
              return cb(CB_SUCCESS, void 0);
            } else {
              ctx.fb.say("Cake cafebuild " + mod_src + " brewed");
              if (stdout) {
                ctx.fb.say(("STDOUT: " + stdout).replace(/\n$/, ''));
              }
              if (stderr) {
                ctx.fb.say(("STDERR: " + stderr).replace(/\n$/, ''));
              }
              return cb(CB_SUCCESS, target_full_fn);
            }
          });
        };
        if ((extend(ctx, opts)).own_args.f) {
          return do_compile(cb);
        } else {
          return maybe_build(mod_src, target_full_fn, function(state, filename) {
            if (state) {
              return do_compile(cb);
            } else {
              ctx.fb.shout("" + mod_src + " still hot");
              ctx.emitter.emit("COMPILE_MAYBE_SKIPPED");
              return typeof cb === "function" ? cb(CB_SUCCESS, filename, "COMPILE_MAYBE_SKIPPED") : void 0;
            }
          });
        }
      };
      last_modified = function(cb) {
        var mod_src;
        mod_src = get_paths(ctx).mod_src;
        return walk(mod_src, function(err, results) {
          var max_time;
          if (results) {
            max_time = (function() {
              try {
                return newest(results.map(function(filename) {
                  return get_mtime(filename);
                }));
              } catch (ex) {
                return 0;
              }
            })();
            return cb(CB_SUCCESS, max_time);
          } else {
            return cb(CB_SUCCESS, 0);
          }
        });
      };
      return {
        type: type,
        get_deps: get_deps,
        harvest: harvest,
        last_modified: last_modified
      };
    };
    return {
      match: match,
      make_adaptor: make_adaptor
    };
  })();

}).call(this);
