// Generated by CoffeeScript 1.4.0
(function() {
  var CB_SUCCESS, COFFEESCRIPT_EXT, CS_EXT, FILE_ENCODING, JS_EXT, TMP_BUILD_DIR_SUFFIX, and_, async, cs, fs, get_mtime, get_paths, get_result_filename, get_target_fn, has_ext, is_file, newer, path, say, scream, shout, whisper, _ref, _ref1, _ref2;

  fs = require('fs');

  path = require('path');

  cs = require('coffee-script');

  _ref = require('../lib/utils'), is_file = _ref.is_file, has_ext = _ref.has_ext, get_mtime = _ref.get_mtime, newer = _ref.newer, get_result_filename = _ref.get_result_filename, and_ = _ref.and_;

  _ref1 = (require('../lib/logger'))("Adaptor/coffee>"), say = _ref1.say, shout = _ref1.shout, scream = _ref1.scream, whisper = _ref1.whisper;

  async = require('async');

  _ref2 = require('../defs'), FILE_ENCODING = _ref2.FILE_ENCODING, TMP_BUILD_DIR_SUFFIX = _ref2.TMP_BUILD_DIR_SUFFIX, CS_EXT = _ref2.CS_EXT, JS_EXT = _ref2.JS_EXT, CB_SUCCESS = _ref2.CB_SUCCESS, COFFEESCRIPT_EXT = _ref2.COFFEESCRIPT_EXT;

  get_target_fn = function(app_root, module_name) {
    return path.resolve(app_root, TMP_BUILD_DIR_SUFFIX, (module_name.replace(new RegExp("" + CS_EXT + "$"), '')) + JS_EXT);
  };

  get_paths = function(ctx) {
    var app_root, module_name, src, target_fn;
    app_root = path.resolve(ctx.own_args.app_root);
    module_name = ctx.own_args.mod_name;
    src = path.resolve(ctx.own_args.src || (path.resolve(app_root, module_name)));
    target_fn = ctx.own_args.js_path ? get_result_filename(src, ctx.own_args.js_path, CS_EXT, JS_EXT) : get_target_fn(path.resolve(ctx.own_args.app_root), path.basename(module_name));
    return {
      source_fn: src || (path.resolve(app_root, module_name)),
      target_fn: target_fn
    };
  };

  module.exports = (function() {
    var make_adaptor, match;
    match = function(ctx) {
      var source_fn;
      source_fn = get_paths(ctx).source_fn;
      return (is_file(source_fn)) && (has_ext(source_fn, COFFEESCRIPT_EXT));
    };
    match.async = function(ctx, cb) {
      var source_fn;
      source_fn = get_paths(ctx).source_fn;
      return async.parallel([
        (function(is_file_cb) {
          return is_file.async(source_fn, is_file_cb);
        }), (function(has_ext_cb) {
          return has_ext.async(source_fn, COFFEESCRIPT_EXT, has_ext_cb);
        })
      ], function(err, res) {
        if (!err && (and_.apply(null, res))) {
          return cb(CB_SUCCESS, true);
        } else {
          return cb(CB_SUCCESS, false);
        }
      });
    };
    make_adaptor = function(ctx) {
      var get_deps, harvest, last_modified, type;
      type = 'plain_coffeescript_file';
      get_deps = function(recipe_deps, cb) {
        var deps, group, group_deps, module_name;
        module_name = ctx.own_args.mod_name;
        for (group in recipe_deps) {
          deps = recipe_deps[group];
          if (group === module_name) {
            group_deps = deps.concat();
          }
        }
        return cb(CB_SUCCESS, group_deps || []);
      };
      harvest = function(cb) {
        var source_fn, target_fn, _ref3;
        _ref3 = get_paths(ctx), source_fn = _ref3.source_fn, target_fn = _ref3.target_fn;
        return fs.exists(source_fn, function(exists) {
          if (exists) {
            if (ctx.own_args.f || (newer(source_fn, target_fn))) {
              return fs.readFile(source_fn, FILE_ENCODING, function(err, data) {
                var js;
                if (err) {
                  ctx.fb.scream("Can't read file " + source_fn + ": " + err);
                  return cb(CB_SUCCESS, void 0);
                } else {
                  js = (function() {
                    try {
                      return cs.compile(data.toString());
                    } catch (e) {
                      try {
                        fs.unlinkSync(target_fn);
                      } catch (e) {

                      }
                      ctx.fb.scream("Error compiling " + source_fn + ": " + e);
                      scream("Error compiling " + source_fn + ": " + e);
                      whisper("" + e.stack);
                      return cb('adaptor_error', e);
                    }
                  })();
                  return fs.writeFile(target_fn, js, FILE_ENCODING, function(err) {
                    if (err) {
                      ctx.fb.scream("Can't write file " + target_fn + ": " + err);
                      return cb(CB_SUCCESS, void 0);
                    } else {
                      ctx.fb.say("" + target_fn + " brewed.");
                      return cb(CB_SUCCESS, target_fn);
                    }
                  });
                }
              });
            } else {
              ctx.fb.shout("" + source_fn + " still hot");
              return cb(CB_SUCCESS, target_fn, "COMPILE_MAYBE_SKIPPED");
            }
          } else {
            ctx.fb.scream("No such file: " + source_fn);
            return cb(CB_SUCCESS, void 0);
          }
        });
      };
      last_modified = function(cb) {
        var source_fn;
        source_fn = get_paths(ctx).source_fn;
        return cb(CB_SUCCESS, get_mtime(source_fn));
      };
      return {
        type: type,
        get_deps: get_deps,
        harvest: harvest,
        last_modified: last_modified
      };
    };
    return {
      match: match,
      make_adaptor: make_adaptor
    };
  })();

}).call(this);
