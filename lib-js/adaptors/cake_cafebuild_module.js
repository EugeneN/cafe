// Generated by CoffeeScript 1.3.3
(function() {
  var CAFE_TARGET_FN_ENV_NAME, CAFE_TMP_BUILD_ROOT_ENV_NAME, CAKEFILE, CAKE_BIN, CAKE_TARGET, CB_SUCCESS, FILE_ENCODING, JS_EXT, NODE_PATH, Package, TMP_BUILD_DIR_SUFFIX, and_, async, cs, exec, extend, fs, get_mtime, get_paths, get_target_fn, has_ext, is_dir, is_file, maybe_build, newer, newest, partial, path, say, scream, shout, stitch, walk, whisper, _, _ref, _ref1, _ref2,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  cs = require('coffee-script');

  exec = require('child_process').exec;

  _ref = (require('../lib/logger'))("Adaptor/Cakefile>"), say = _ref.say, shout = _ref.shout, scream = _ref.scream, whisper = _ref.whisper;

  _ref1 = require('../lib/utils'), maybe_build = _ref1.maybe_build, is_dir = _ref1.is_dir, is_file = _ref1.is_file, has_ext = _ref1.has_ext, and_ = _ref1.and_, get_mtime = _ref1.get_mtime, newer = _ref1.newer, walk = _ref1.walk, newest = _ref1.newest, extend = _ref1.extend;

  async = require('async');

  stitch = new require('../lib/stitch');

  Package = new stitch.Package({});

  _ = require('underscore');

  _ref2 = require('../defs'), FILE_ENCODING = _ref2.FILE_ENCODING, TMP_BUILD_DIR_SUFFIX = _ref2.TMP_BUILD_DIR_SUFFIX, JS_EXT = _ref2.JS_EXT, CAKE_BIN = _ref2.CAKE_BIN, CAKE_TARGET = _ref2.CAKE_TARGET, NODE_PATH = _ref2.NODE_PATH, CAKEFILE = _ref2.CAKEFILE, CB_SUCCESS = _ref2.CB_SUCCESS, CAFE_TMP_BUILD_ROOT_ENV_NAME = _ref2.CAFE_TMP_BUILD_ROOT_ENV_NAME, CAFE_TARGET_FN_ENV_NAME = _ref2.CAFE_TARGET_FN_ENV_NAME;

  stitch = require('../lib/stitch');

  partial = function() {
    var args, fn;
    fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return _.bind.apply(_, [fn, null].concat(__slice.call(args)));
  };

  get_target_fn = function(js_path, app_root, target_fn) {
    if (js_path) {
      return path.resolve(js_path, target_fn);
    } else {
      return path.resolve(app_root, TMP_BUILD_DIR_SUFFIX, target_fn);
    }
  };

  get_paths = function(ctx) {
    var app_root, cakefile, js_path, mod_src, module_name, src, target_fn, target_full_fn, tmp_build_root;
    app_root = path.resolve(ctx.own_args.app_root);
    module_name = ctx.own_args.mod_name;
    src = ctx.own_args.src;
    js_path = ctx.own_args.js_path;
    mod_src = src || path.resolve(app_root, module_name);
    cakefile = path.resolve(mod_src, CAKEFILE);
    target_fn = path.basename(module_name + JS_EXT);
    target_full_fn = get_target_fn(js_path, app_root, target_fn);
    tmp_build_root = js_path || path.resolve(app_root, TMP_BUILD_DIR_SUFFIX);
    return {
      mod_src: mod_src,
      cakefile: cakefile,
      target_fn: target_fn,
      target_full_fn: target_full_fn,
      tmp_build_root: tmp_build_root
    };
  };

  module.exports = (function() {
    var make_adaptor, match;
    match = function(ctx) {
      var cakefile, mod_src, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, cakefile = _ref3.cakefile;
      return (is_dir(mod_src)) && (is_file(cakefile));
    };
    match.async = function(ctx, cb) {
      var cakefile, mod_src, _ref3;
      _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, cakefile = _ref3.cakefile;
      return async.parallel([
        (function(is_dir_cb) {
          return is_dir.async(mod_src, is_dir_cb);
        }), (function(is_file_cb) {
          return is_file.async(cakefile, is_file_cb);
        })
      ], function(err, res) {
        if (!err && (and_.apply(null, res))) {
          return cb(CB_SUCCESS, true);
        } else {
          return cb(CB_SUCCESS, false);
        }
      });
    };
    make_adaptor = function(ctx) {
      var get_deps, harvest, last_modified, type;
      type = 'cakefile';
      get_deps = function(recipe_deps, cb) {
        var deps, group, group_deps, module_name;
        module_name = ctx.own_args.mod_name;
        for (group in recipe_deps) {
          deps = recipe_deps[group];
          if (group === module_name) {
            group_deps = deps.concat();
          }
        }
        return cb(CB_SUCCESS, group_deps || []);
      };
      harvest = function(harvest_cb, opts) {
        var check_maybe_do, do_cake, done, mod_src, put_to_tmp_storage, safe_parse_json_or_undefined, stitching, target_fn, target_full_fn, tmp_build_root, _ref3;
        if (opts == null) {
          opts = {};
        }
        _ref3 = get_paths(ctx), mod_src = _ref3.mod_src, target_full_fn = _ref3.target_full_fn, target_fn = _ref3.target_fn, tmp_build_root = _ref3.tmp_build_root;
        check_maybe_do = function(cb) {
          return maybe_build(mod_src, target_full_fn, function(changed, filename) {
            if (changed || (extend(ctx, opts)).own_args.f) {
              return cb();
            } else {
              return cb('Maybe skipped');
            }
          });
        };
        do_cake = function(cb) {
          opts = {
            cwd: mod_src,
            env: process.env
          };
          return exec([CAKE_BIN, CAKE_TARGET].join(' '), opts, function(err, results) {
            return cb(err, results);
          });
        };
        safe_parse_json_or_undefined = function(result, cb) {
          console.log(result);
          try {
            return cb(null, JSON.parse(result));
          } catch (ex) {
            throw ex;
            return cb('Parser error');
          }
        };
        stitching = function(files, cb) {
          var ext_length, filename, fn, source, sources, _i, _len, _ref4;
          sources = {};
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            _ref4 = files[_i], fn = _ref4[0], source = _ref4[1];
            ext_length = (path.extname(fn)).length;
            filename = fn.slice(0, -ext_length);
            sources[filename] = {
              filename: fn,
              source: source
            };
          }
          return cb(null, Package.get_result_bundle(sources));
        };
        put_to_tmp_storage = function(key, data, cb) {
          return fs.writeFile(key, data, function(err) {
            if (err) {
              cb(err);
            }
            return typeof cb === "function" ? cb(null, key) : void 0;
          });
        };
        done = function(err, res) {
          switch (err) {
            case null:
              ctx.fb.say('OK');
              return harvest_cb(CB_SUCCESS, target_full_fn);
            case "MAYBE_SKIP":
              ctx.fb.shout("maybe skipped");
              return harvest_cb(null);
            default:
              ctx.fb.scream("not ok");
              return harvest_cb(err, res);
          }
        };
        return async.waterfall([check_maybe_do, do_cake, safe_parse_json_or_undefined, stitching, partial(put_to_tmp_storage, target_full_fn)], done);
      };
      last_modified = function(cb) {
        var mod_src;
        mod_src = get_paths(ctx).mod_src;
        return walk(mod_src, function(err, results) {
          var max_time;
          if (results) {
            max_time = (function() {
              try {
                return newest(results.map(function(filename) {
                  return get_mtime(filename);
                }));
              } catch (ex) {
                return 0;
              }
            })();
            return cb(CB_SUCCESS, max_time);
          } else {
            return cb(CB_SUCCESS, 0);
          }
        });
      };
      return {
        type: type,
        get_deps: get_deps,
        harvest: harvest,
        last_modified: last_modified
      };
    };
    return {
      match: match,
      make_adaptor: make_adaptor
    };
  })();

}).call(this);
