// Generated by CoffeeScript 1.3.3
(function() {
  var SEP, SUB_CAFE, THRESHOLD_INTERVAL, THRESHOLD_QUEUE_ACTIVE, THRESHOLD_QUEUE_EMPTY, WATCH_FN_PATTERN, async, build, build_cmd, chokidar, filter_dict, fork, fs, is_array, is_debug_context, maybe_build, path, path_matches, say, scream, shout, spawn, watch, whisper, _get_build_dir, _ref, _ref1, _ref2, _ref3;

  fs = require('fs');

  path = require('path');

  async = require('async');

  watch = require('watch');

  chokidar = require('chokidar');

  _ref = require('child_process'), fork = _ref.fork, spawn = _ref.spawn;

  _ref1 = (require('./logger'))("Watcher>"), say = _ref1.say, shout = _ref1.shout, scream = _ref1.scream, whisper = _ref1.whisper;

  _ref2 = require('./utils'), maybe_build = _ref2.maybe_build, filter_dict = _ref2.filter_dict, is_array = _ref2.is_array, is_debug_context = _ref2.is_debug_context;

  SEP = '/';

  _ref3 = require('../defs'), WATCH_FN_PATTERN = _ref3.WATCH_FN_PATTERN, SUB_CAFE = _ref3.SUB_CAFE, THRESHOLD_INTERVAL = _ref3.THRESHOLD_INTERVAL;

  THRESHOLD_QUEUE_ACTIVE = false;

  THRESHOLD_QUEUE_EMPTY = true;

  build_cmd = function(full_args, build_path) {
    /*
        Function for initializing cmd for executing after some file was changed.
    */

    var arg, arg1, arg2, args, cmdline, command, filter_arg, filtered_args, format_arg, val, _ref4;
    filtered_args = filter_dict(full_args, function(k, v) {
      return k !== 'watch' && k !== 'global';
    });
    arg1 = function(arg) {
      return "-" + arg;
    };
    arg2 = function(arg, val) {
      return "--" + arg + (val === void 0 ? '' : '=' + val);
    };
    format_arg = function(arg, val) {
      if (val === true) {
        return arg1(arg);
      } else {
        return arg2(arg, val);
      }
    };
    filter_arg = function(command, arg, val) {
      if (val === true) {
        return arg1(arg);
      } else {
        return arg2(arg, val);
      }
    };
    cmdline = ['--nologo', '--child'];
    if (is_debug_context(full_args)) {
      cmdline.push('--debug');
    }
    _ref4 = full_args.global;
    for (arg in _ref4) {
      val = _ref4[arg];
      cmdline.push(format_arg(arg, val));
    }
    for (command in filtered_args) {
      args = filtered_args[command];
      cmdline.push("" + command);
      for (arg in args) {
        val = args[arg];
        cmdline.push(filter_arg(command, arg, val));
      }
    }
    return cmdline;
  };

  build = function(ctx, build_cmd_gen, build_root) {
    var child, cmd_args, opts;
    cmd_args = build_cmd_gen(build_root);
    opts = {
      env: process.env,
      cwd: process.env.PWD
    };
    child = spawn(SUB_CAFE, cmd_args, opts);
    child.on('message', function(m) {
      return ctx.fb.murmur(m);
    });
    child.stdout.on('data', function(data) {
      return ctx.fb.say(("" + data).replace(/\n$/, ''));
    });
    child.stderr.on('data', function(data) {
      return ctx.fb.scream(("" + data).replace(/\n$/, ''));
    });
    return child.on('exit', function(code) {
      if (code === 0) {
        return ctx.fb.say("=== Watch cycle sequence succeeded ===========================");
      } else {
        return ctx.fb.scream("=== Watch cycle sequence failed with code " + code + " ===========");
      }
    });
  };

  _get_build_dir = function(watch_root, file) {
    var base, current, i;
    base = (function() {
      var _i, _len, _ref4, _results;
      _ref4 = watch_root.split(SEP);
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        i = _ref4[_i];
        if (i) {
          _results.push(i);
        }
      }
      return _results;
    })();
    current = (function() {
      var _i, _len, _ref4, _results;
      _ref4 = file.split(SEP);
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        i = _ref4[_i];
        if (i) {
          _results.push(i);
        }
      }
      return _results;
    })();
    return base.concat(current.slice(base.length)[0]).join(SEP);
  };

  path_matches = function(paths, s) {
    var full_s;
    full_s = path.resolve(s);
    return (paths.map(function(p) {
      var r;
      r = new RegExp("^" + (path.resolve(p)));
      return r.test(full_s);
    })).reduce(function(a, b) {
      return a || b;
    });
  };

  module.exports = {
    watch: function(ctx) {
      var builder, modules;
      modules = [path.resolve(ctx.watch_root)];
      builder = build.partial(ctx, build_cmd.partial(ctx.orig_ctx.full_args));
      modules.map(function(module_root) {
        var change_handler, check_queue, do_build, skip, watcher,
          _this = this;
        check_queue = function() {
          if (!THRESHOLD_QUEUE_EMPTY) {
            return do_build();
          } else {
            return THRESHOLD_QUEUE_ACTIVE = false;
          }
        };
        do_build = function() {
          setTimeout(check_queue, THRESHOLD_INTERVAL);
          THRESHOLD_QUEUE_ACTIVE = true;
          THRESHOLD_QUEUE_EMPTY = true;
          return builder(module_root);
        };
        do_build();
        skip = ctx.orig_ctx.own_args.skip ? is_array(ctx.orig_ctx.own_args.skip) ? ctx.orig_ctx.own_args.skip.map(function(path_suffix) {
          return path.resolve(module_root, path_suffix);
        }) : [path.resolve(module_root, ctx.orig_ctx.own_args.skip)] : void 0;
        change_handler = function(file) {
          var fn;
          if (!(skip && (path_matches(skip, file)))) {
            fn = path.basename(file);
            if (WATCH_FN_PATTERN.test(fn)) {
              if (THRESHOLD_QUEUE_ACTIVE) {
                shout("" + file + " has been changed, but skipping brewing due to threshold limit");
                return THRESHOLD_QUEUE_EMPTY = false;
              } else {
                say("Coffee " + file + " is cold. Preparing new...");
                return do_build();
              }
            }
          }
        };
        ctx.fb.scream(module_root);
<<<<<<< HEAD
        watcher = chokidar.watch(module_root, {
          ignored: /^\./,
          persistent: true
        });
        watcher.on('change', change_handler);
        return watcher.on('error', function(error) {
          return ctx.fb.scream("watcher encauntered an error " + error);
        });
=======
        if (!watcher) {
          watcher = chokidar.watch(module_root, {
            ignored: /^\./,
            persistent: true
          });
          watcher.on('change', change_handler);
          return watcher.on('error', function(error) {
            return ctx.fb.scream("watcher encauntered an error " + error);
          });
        } else {
          return watcher.add(module_root);
        }
>>>>>>> growl
      });
      return ctx.fb.say("Started growing Coffee on the plantation '" + ctx.watch_root + "'");
    }
  };

}).call(this);
