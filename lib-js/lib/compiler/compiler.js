// Generated by CoffeeScript 1.4.0
(function() {
  var make_compiler, p;

  p = require('path');

  make_compiler = function(compilers) {
    var c, validate_compiler, _i, _len;
    compilers || (compilers = []);
    validate_compiler = function(compiler) {
      return (compiler.hasOwnProperty('ext')) && (compiler.hasOwnProperty('compile'));
    };
    for (_i = 0, _len = compilers.length; _i < _len; _i++) {
      c = compilers[_i];
      if (!(validate_compiler(c))) {
        throw "Copmiler " + c + " has wrong interface";
      }
    }
    return {
      register_compiler_by_path: function(path) {
        "Registers compiler by filename.";

        var compiler;
        compiler = require(path);
        if (validate_compiler(compiler)) {
          return compilers.push(compiler);
        } else {
          throw "Compiler from path " + path + " must implement methods 'match' and 'compile'";
        }
      },
      register_compiler: function(compiler) {
        if (validate_compiler(compiler)) {
          return compilers.push(compiler);
        } else {
          throw "Compiler " + compiler + " must implement methods 'match' and 'compile'";
        }
      },
      compile: function(paths) {
        "@paths: list of paths for compilation.\nReturns:\n    {path, source}";

        var get_compiler;
        get_compiler = function(path, compilers) {
          var _j, _len1;
          for (_j = 0, _len1 = compilers.length; _j < _len1; _j++) {
            c = compilers[_j];
            if (c.ext === (p.extname(path)).slice(1)) {
              return c;
            }
          }
          throw "No compiler is registered for path " + path;
        };
        return paths.map(function(p) {
          try {
            return {
              path: p,
              source: get_compiler(p, compilers).compile(p)
            };
          } catch (e) {
            throw "Failed to compile file " + p + ". " + e;
          }
        });
      }
    };
  };

  module.exports = make_compiler;

}).call(this);
