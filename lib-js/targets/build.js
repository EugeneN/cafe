// Generated by CoffeeScript 1.3.3
(function() {
  var BUILD_DEPS_FN, CB_SUCCESS, FILE_ENCODING, RECIPE, RECIPE_API_LEVEL, RECIPE_EXT, TMP_BUILD_DIR_SUFFIX, add, async, build, build_bundle, build_bundles, check_ctx, compose, extend, filter_duplicates, fs, get_build_dir, get_ctx_recipe, get_opt, get_recipe, has_ext, help, is_dir, is_file, make_target, map, map_sort_bundles, partial, path, process_realms, read_json_file, resolve_deps, run_target, say, scream, shout, show_bundles, show_realms, toposort, whisper, write_build_deps_file, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  help = ["Reads a recipe and build an application according to the recipe.\nResolves dependencies (up to 5 lvls deep), compiles them using appropriate\nadapters, generates build deps spec for use outside of the applications.\n\nParameters:\n    - app_root    - directory with client-side sources\n\n    - build_root  - directory to put built code into\n\n    - formula     - formula to use for each particular build,\n                    'recipe.json' by default\n\nThere may be 3 types of dependencies in recipe.json\nand in `recipe` array in slug.json files\n\n    1. CoffeeScript modules\n    2. JavaScript group (i.e. `jquery` is a group that includes\n       jquery itself but also jquery-ui and jquery.cookie)\n    3. JavaScript file\n\n1) CoffeeScript modules are specified by names. Appropriate adapter will look\n   for the respective location on th filesystem.\n\n(2) JavaScript groups are described in recipe.json in `deps`. Path specifications\n    must match those of (3).\n\n    Example (in recipe.json):\n        \"deps\":{\n            \"utils\": [\n                \"shopping_cart.js\",\n                \"uaprom_common.js\",\n                \"utils.js\"\n            ]\n        },\n\n(3) JavaScript files must be specified by a path relative to\n    the recipe.json location.\n\n    Example:\n        \"baselib/uaprom.js\",                // <- file in build_root\n        \"baselib/jquery/jquery-1.6.2.js\",   // <- file in subdir jquery of build_root\n\nEach particular adaptor may use it's own algorythms for dependencies resolving\nand filesystem lookup.\n\n\n"];

  fs = require('fs');

  path = require('path');

  async = require('async');

  _ref = require('functools'), compose = _ref.compose, map = _ref.map, partial = _ref.partial;

  _ref1 = require('../lib/target'), make_target = _ref1.make_target, run_target = _ref1.run_target;

  _ref2 = require('../lib/bundler'), resolve_deps = _ref2.resolve_deps, build_bundle = _ref2.build_bundle, toposort = _ref2.toposort;

  _ref3 = (require('../lib/logger'))("Build>"), say = _ref3.say, shout = _ref3.shout, scream = _ref3.scream, whisper = _ref3.whisper;

  _ref4 = require('../lib/utils'), read_json_file = _ref4.read_json_file, add = _ref4.add, is_dir = _ref4.is_dir, is_file = _ref4.is_file, has_ext = _ref4.has_ext, extend = _ref4.extend, get_opt = _ref4.get_opt;

  _ref5 = require('../defs'), TMP_BUILD_DIR_SUFFIX = _ref5.TMP_BUILD_DIR_SUFFIX, RECIPE = _ref5.RECIPE, RECIPE_EXT = _ref5.RECIPE_EXT, BUILD_DEPS_FN = _ref5.BUILD_DEPS_FN, FILE_ENCODING = _ref5.FILE_ENCODING, CB_SUCCESS = _ref5.CB_SUCCESS, RECIPE_API_LEVEL = _ref5.RECIPE_API_LEVEL;

  get_build_dir = function(build_root) {
    return path.resolve(path.join(build_root, TMP_BUILD_DIR_SUFFIX));
  };

  get_recipe = function(recipe_path, level) {
    var base_recipe, base_recipe_path, recipe, _ref6;
    if (level == null) {
      level = 0;
    }
    if (level > 3) {
      scream("Recipe inheritance chain to long");
      return void 0;
    } else if (is_file(recipe_path)) {
      recipe = read_json_file(recipe_path);
      if (recipe != null ? (_ref6 = recipe.abstract) != null ? _ref6["extends"] : void 0 : void 0) {
        base_recipe_path = path.resolve(path.dirname(recipe_path), recipe.abstract["extends"]);
        if (base_recipe_path !== recipe_path) {
          if ((base_recipe = get_recipe(base_recipe_path, level + 1))) {
            return extend(base_recipe, recipe);
          } else {
            scream("Can't read base recipe " + base_recipe_path);
            return void 0;
          }
        } else {
          scream("Cyclic dependency found in recipe inheritance chain");
          return void 0;
        }
      } else {
        return recipe;
      }
    } else {
      return void 0;
    }
  };

  show_realms = function(ctx, recipe) {
    var realm;
    return ctx.fb.say("Realms found: " + (((function() {
      var _results;
      _results = [];
      for (realm in recipe.realms) {
        _results.push(realm);
      }
      return _results;
    })()).join(', ')));
  };

  show_bundles = function(ctx, realm, bundles) {
    var bundle;
    return ctx.fb.say("Bundles found for " + realm + ": " + (((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = bundles.length; _i < _len; _i++) {
        bundle = bundles[_i];
        _results.push(bundle.name);
      }
      return _results;
    })()).join(', ')));
  };

  write_build_deps_file = function(ctx, fn, deps, cb) {
    return fs.writeFile(fn, JSON.stringify(deps, null, 4), FILE_ENCODING, function(err) {
      if (err) {
        ctx.fb.scream("Failed to write build deps file " + fn + ": " + err + ".");
        return cb("fs_error", err);
      } else {
        ctx.fb.say("Build deps file " + fn + " written.");
        return cb(CB_SUCCESS);
      }
    });
  };

  check_ctx = function(ctx, cb) {
    if (!(ctx.own_args.app_root && ctx.own_args.build_root)) {
      return cb(["app_root and/or build_root arguments missing", 'bad_ctx']);
    } else if (!is_dir(ctx.own_args.app_root)) {
      return cb(["App root " + ctx.own_args.app_root + " is not a directory", 'bad_ctx']);
    } else {
      return cb(CB_SUCCESS, true);
    }
  };

  get_ctx_recipe = function(ctx, ctx_is_valid, cb) {
    var recipe, recipe_path, _ref6;
    if (!ctx_is_valid) {
      return cb('bad_ctx');
    }
    recipe_path = path.resolve(ctx.own_args.app_root, ctx.own_args.formula || RECIPE);
    recipe = get_recipe(recipe_path);
    if (!recipe) {
      return cb('bad_ctx', "Bad recipe " + recipe_path);
    } else if (((_ref6 = recipe.abstract) != null ? _ref6.api_version : void 0) !== RECIPE_API_LEVEL) {
      return cb('bad_recipe', "Current Cafe version is not compatible with the " + "recipe.json version. Please update Cafe and try again.");
    } else {
      return cb(CB_SUCCESS, recipe);
    }
  };

  map_sort_bundles = function(ctx, bundles, recipe, realm, map_sort_bundles_cb) {
    var resolve_all_deps, resolve_sub_deps, sort_bundles;
    resolve_sub_deps = function(found_modules, resolve_sub_deps_cb) {
      var args, d, first_level_deps, m;
      first_level_deps = add.apply(null, (function() {
        var _results;
        _results = [];
        for (m in found_modules) {
          d = found_modules[m];
          _results.push(d.deps);
        }
        return _results;
      })());
      args = {
        modules: first_level_deps,
        app_root: ctx.own_args.app_root,
        recipe_deps: recipe.deps,
        ctx: ctx
      };
      return resolve_deps(args, function(err, found_modules_second_level) {
        var deps, module;
        for (module in found_modules_second_level) {
          deps = found_modules_second_level[module];
          if (!(__indexOf.call(found_modules, module) >= 0)) {
            found_modules[module] = deps;
          }
        }
        return resolve_sub_deps_cb(CB_SUCCESS, found_modules);
      });
    };
    resolve_all_deps = function(args, resolve_all_deps_cb) {
      return async.waterfall(add([
        (function(args) {
          return function(cb) {
            return resolve_deps(args, cb);
          };
        })(args)
      ], [1, 2, 3, 4, 5].map(function() {
        return resolve_sub_deps;
      })), resolve_all_deps_cb);
    };
    sort_bundles = function(bundle, sort_bundles_cb) {
      var args;
      args = {
        modules: bundle.modules,
        app_root: ctx.own_args.app_root,
        recipe_deps: recipe.deps,
        ctx: ctx
      };
      return resolve_all_deps(args, function(err, modules) {
        var sorted_modules;
        sorted_modules = toposort({
          realm: realm,
          bundle: bundle
        }, modules);
        return sort_bundles_cb(CB_SUCCESS, sorted_modules);
      });
    };
    return async.map(bundles, sort_bundles, map_sort_bundles_cb);
  };

  filter_duplicates = function(bundles_sorted_list) {
    var filtered_bundles, _i, _ref6, _results;
    filtered_bundles = (function() {
      _results = [];
      for (var _i = 0, _ref6 = bundles_sorted_list.length; 0 <= _ref6 ? _i < _ref6 : _i > _ref6; 0 <= _ref6 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      var m, prev_bundles, prev_bundles_names, _i, _len, _ref6, _ref7, _results;
      prev_bundles = (add.apply(null, bundles_sorted_list.slice(0, i))) || [];
      prev_bundles_names = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = prev_bundles.length; _i < _len; _i++) {
          m = prev_bundles[_i];
          _results.push(m.name);
        }
        return _results;
      })();
      _ref6 = bundles_sorted_list[i];
      _results = [];
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        m = _ref6[_i];
        if (!(_ref7 = m.name, __indexOf.call(prev_bundles_names, _ref7) >= 0)) {
          _results.push(m);
        }
      }
      return _results;
    });
    return filtered_bundles;
  };

  build_bundles = function(ctx, bundles, recipe, realm, filtered_bundles, build_bundles_cb) {
    var build_bundle_wrapper, build_bundles_done, _i, _ref6, _results;
    build_bundle_wrapper = function(index, build_bundle_wrapper_cb) {
      var build_bundle_cb, force_bundle, force_compile, maybe_minify;
      maybe_minify = get_opt('minify', bundles[index].opts, recipe.opts);
      force_compile = get_opt('force_compile', bundles[index].opts, recipe.opts);
      force_bundle = get_opt('force_bundle', bundles[index].opts, recipe.opts);
      build_bundle_cb = function(err, res) {
        var args, bundle_name, mod_status, not_changed, post_build_bundle_cb;
        if (err) {
          return build_bundle_wrapper_cb(err, res);
        } else {
          realm = res[0], bundle_name = res[1], not_changed = res[2];
          mod_status = {};
          mod_status[realm] = {};
          mod_status[realm][bundle_name] = not_changed;
          post_build_bundle_cb = function() {
            return build_bundle_wrapper_cb(CB_SUCCESS, {
              name: bundles[index].name,
              modules: filtered_bundles[index],
              not_changed: mod_status[realm][bundles[index].name]
            });
          };
          if (maybe_minify) {
            args = {
              global: {
                debug: true
              },
              minify: {
                src: path.join(get_build_dir(ctx.own_args.build_root), realm),
                pattern: bundles[index].name
              }
            };
            return run_target('minify', args, ctx, post_build_bundle_cb);
          } else {
            return post_build_bundle_cb();
          }
        }
      };
      return build_bundle({
        realm: realm,
        bundle_name: bundles[index].name,
        bundle_opts: bundles[index].opts,
        force_compile: force_compile,
        force_bundle: force_bundle,
        sorted_modules_list: filtered_bundles[index],
        build_root: get_build_dir(ctx.own_args.build_root),
        ctx: ctx,
        cb: build_bundle_cb
      });
    };
    build_bundles_done = function(err, filtered_bundles_list) {
      var no_changes, result;
      if (err) {
        ctx.fb.scream("Level 1 build error: " + err);
        return build_bundles_cb(err);
      } else {
        result = {};
        no_changes = (filtered_bundles_list.map(function(_arg) {
          var modules, name, not_changed;
          name = _arg.name, modules = _arg.modules, not_changed = _arg.not_changed;
          result[name] = modules;
          return not_changed;
        })).reduce(function(a, b) {
          return a && b;
        });
        return build_bundles_cb(CB_SUCCESS, {
          name: realm,
          bundles: result,
          not_changed: no_changes
        });
      }
    };
    return async.map((function() {
      _results = [];
      for (var _i = 0, _ref6 = filtered_bundles.length; 0 <= _ref6 ? _i < _ref6 : _i > _ref6; 0 <= _ref6 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), build_bundle_wrapper, build_bundles_done);
  };

  process_realms = function(ctx, recipe, cb) {
    var done_processing_realms, k, process_realm, v;
    show_realms(ctx, recipe);
    process_realm = function(_arg, process_realm_cb) {
      var bundles, realm;
      realm = _arg[0], bundles = _arg[1];
      show_bundles(ctx, realm, bundles);
      return map_sort_bundles(ctx, bundles, recipe, realm, function(err, bundles_sorted_list) {
        var filtered_bundles;
        filtered_bundles = filter_duplicates(bundles_sorted_list);
        return build_bundles(ctx, bundles, recipe, realm, filtered_bundles, function(err, sorted_realms) {
          return process_realm_cb(err, sorted_realms);
        });
      });
    };
    done_processing_realms = function(err, sorted_realms) {
      var fn, no_changes, result;
      if (err) {
        ctx.fb.scream("Level 0 build error: " + err);
        return cb(err, sorted_realms);
      } else {
        result = {};
        no_changes = (sorted_realms.map(function(_arg) {
          var bundles, name, not_changed;
          name = _arg.name, bundles = _arg.bundles, not_changed = _arg.not_changed;
          result[name] = bundles;
          return not_changed;
        })).reduce(function(a, b) {
          return a && b;
        });
        if (!no_changes) {
          fn = path.resolve(get_build_dir(ctx.own_args.build_root), BUILD_DEPS_FN);
          return write_build_deps_file(ctx, fn, result, cb);
        } else {
          ctx.fb.shout("" + BUILD_DEPS_FN + " still hot");
          return cb(CB_SUCCESS);
        }
      }
    };
    return async.map((function() {
      var _ref6, _results;
      _ref6 = recipe.realms;
      _results = [];
      for (k in _ref6) {
        v = _ref6[k];
        _results.push([k, v]);
      }
      return _results;
    })(), process_realm, done_processing_realms);
  };

  build = function(ctx, build_cb) {
    var a, b;
    a = (function(ctx) {
      return function(val, cb) {
        return get_ctx_recipe(ctx, val, cb);
      };
    })(ctx);
    b = (function(ctx) {
      return function(val, cb) {
        return process_realms(ctx, val, cb);
      };
    })(ctx);
    return (compose.async(check_ctx, a, b))(ctx, build_cb);
  };

  module.exports = make_target("build", build, help);

}).call(this);
