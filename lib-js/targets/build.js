// Generated by CoffeeScript 1.6.1
(function() {
  var BUILD_DEPS_FN, CB_SUCCESS, FILE_ENCODING, RECIPE, RECIPE_API_LEVEL, RECIPE_EXT, TMP_BUILD_DIR_SUFFIX, add, async, build, build_bundle, build_bundles, check_ctx, compose, extend, filter_dict, filter_duplicates, fs, get_cafe_dir, get_ctx_recipe, get_legacy_cafe_bin_path, get_modules_cache_dir, get_opt, get_tmp_build_dir, has_ext, help, is_dir, is_file, make_target, map, map_sort_bundles, partial, path, process_realms, read_json_file, read_recipe, resolve_deps, run_target, show_bundles, show_realms, spawn, toposort, write_build_deps_file, _ref, _ref1, _ref2, _ref3, _ref4,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  help = ["Reads a recipe and build an application according to the recipe.\nResolves dependencies (up to 5 lvls deep), compiles them using appropriate\nadapters, generates build deps spec for use outside of the applications.\n\nParameters:\n    - app_root    - directory with client-side sources\n\n    - build_root  - directory to put built code into\n\n    - formula     - formula to use for each particular build,\n                    'recipe.json' by default\n\nThere may be 3 types of dependencies in recipe.json\nand in `recipe` array in slug.json files\n\n    1. CoffeeScript modules\n    2. JavaScript group (i.e. `jquery` is a group that includes\n       jquery itself but also jquery-ui and jquery.cookie)\n    3. JavaScript file\n\n1) CoffeeScript modules are specified by names. Appropriate adapter will look\n   for the respective location on th filesystem.\n\n(2) JavaScript groups are described in recipe.json in `deps`. Path specifications\n    must match those of (3).\n\n    Example (in recipe.json):\n        \"deps\":{\n            \"utils\": [\n                \"shopping_cart.js\",\n                \"uaprom_common.js\",\n                \"utils.js\"\n            ]\n        },\n\n(3) JavaScript files must be specified by a path relative to\n    the recipe.json location.\n\n    Example:\n        \"baselib/uaprom.js\",                // <- file in build_root\n        \"baselib/jquery/jquery-1.6.2.js\",   // <- file in subdir jquery of build_root\n\nEach particular adaptor may use it's own algorythms for dependencies resolving\nand filesystem lookup.\n\n\n"];

  fs = require('fs');

  path = require('path');

  async = require('async');

  _ref = require('functools'), compose = _ref.compose, map = _ref.map, partial = _ref.partial;

  spawn = require('child_process').spawn;

  _ref1 = require('../lib/target'), make_target = _ref1.make_target, run_target = _ref1.run_target;

  _ref2 = require('../lib/bundler'), resolve_deps = _ref2.resolve_deps, build_bundle = _ref2.build_bundle, toposort = _ref2.toposort;

  read_recipe = require('../lib/build/recipe_reader').read_recipe;

  _ref3 = require('../lib/utils'), read_json_file = _ref3.read_json_file, add = _ref3.add, is_dir = _ref3.is_dir, is_file = _ref3.is_file, has_ext = _ref3.has_ext, extend = _ref3.extend, get_opt = _ref3.get_opt, get_cafe_dir = _ref3.get_cafe_dir, partial = _ref3.partial, get_legacy_cafe_bin_path = _ref3.get_legacy_cafe_bin_path, filter_dict = _ref3.filter_dict;

  _ref4 = require('../defs'), TMP_BUILD_DIR_SUFFIX = _ref4.TMP_BUILD_DIR_SUFFIX, RECIPE = _ref4.RECIPE, RECIPE_EXT = _ref4.RECIPE_EXT, BUILD_DEPS_FN = _ref4.BUILD_DEPS_FN, FILE_ENCODING = _ref4.FILE_ENCODING, CB_SUCCESS = _ref4.CB_SUCCESS, RECIPE_API_LEVEL = _ref4.RECIPE_API_LEVEL;

  get_tmp_build_dir = function(build_root) {
    return path.resolve(path.join(build_root, TMP_BUILD_DIR_SUFFIX));
  };

  get_modules_cache_dir = function(app_root) {
    return path.resolve(path.join(get_cafe_dir(app_root), 'modules_cache'));
  };

  show_realms = function(ctx, recipe) {
    var realm;
    return ctx.fb.say("Realms found: " + (((function() {
      var _results;
      _results = [];
      for (realm in recipe.realms) {
        _results.push(realm);
      }
      return _results;
    })()).join(', ')));
  };

  show_bundles = function(ctx, realm, bundles) {
    var bundle;
    return ctx.fb.say("Bundles found for " + realm + ": " + (((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = bundles.length; _i < _len; _i++) {
        bundle = bundles[_i];
        _results.push(bundle.name);
      }
      return _results;
    })()).join(', ')));
  };

  write_build_deps_file = function(ctx, fn, deps, cb) {
    return fs.writeFile(fn, JSON.stringify(deps, null, 4), FILE_ENCODING, function(err) {
      if (err) {
        ctx.fb.scream("Failed to write build deps file " + fn + ": " + err + ".");
        return cb("fs_error", err);
      } else {
        ctx.fb.say("Build deps file " + fn + " written.");
        return cb(CB_SUCCESS);
      }
    });
  };

  check_ctx = function(ctx, cb) {
    if (!(ctx.own_args.app_root && ctx.own_args.build_root)) {
      return cb(["app_root and/or build_root arguments missing", 'bad_ctx']);
    } else if (!is_dir(ctx.own_args.app_root)) {
      return cb(["App root " + ctx.own_args.app_root + " is not a directory", 'bad_ctx']);
    } else {
      return cb(CB_SUCCESS, true);
    }
  };

  get_ctx_recipe = function(ctx, ctx_is_valid, cb) {
    var arg, arg1, arg2, args, cmd_args, command, error, format_arg, legacy_cafe_bin, recipe, recipe_path, run, val, _ref5, _ref6, _ref7;
    if (!ctx_is_valid) {
      return cb('bad_ctx');
    }
    recipe_path = path.resolve(ctx.own_args.app_root, ctx.own_args.formula || RECIPE);
    _ref5 = read_recipe(recipe_path), error = _ref5[0], recipe = _ref5[1];
    if (!recipe) {
      cb('bad_ctx', "Bad recipe " + error);
    }
    if (recipe.abstract.api_version === RECIPE_API_LEVEL) {
      return cb(CB_SUCCESS, recipe);
    } else {
      arg1 = function(arg) {
        return "-" + arg;
      };
      arg2 = function(arg, val) {
        return "--" + arg + (val === void 0 ? '' : '=' + val);
      };
      format_arg = function(arg, val) {
        if (val === true) {
          return arg1(arg);
        } else {
          return arg2(arg, val);
        }
      };
      ctx.fb.shout("Found old apiversion in recipe " + recipe.abstract.api_version);
      if ((legacy_cafe_bin = get_legacy_cafe_bin_path(recipe.abstract.api_version))) {
        cmd_args = ['--nologo', '--noupdate', '--nogrowl'];
        _ref6 = ctx.global;
        for (arg in _ref6) {
          val = _ref6[arg];
          cmd_args.push(format_arg(arg, val));
        }
        _ref7 = filter_dict(ctx.full_args, function(k, v) {
          return k !== 'global';
        });
        for (command in _ref7) {
          args = _ref7[command];
          cmd_args.push("" + command);
          for (arg in args) {
            val = args[arg];
            cmd_args.push(format_arg(arg, val));
          }
        }
        run = spawn(legacy_cafe_bin, cmd_args);
        run.stdout.on('data', function(data) {
          return ctx.fb.say(("" + data).replace(/\n$/, ''));
        });
        run.stderr.on('data', function(data) {
          return ctx.fb.scream(("" + data).replace(/\n$/, ''));
        });
        return run.on('exit', function(code) {
          return cb('stop');
        });
      } else {
        return cb('bad_recipe', "Current Cafe version is not compatible with the " + "recipe.json version. Please update Cafe and try again.");
      }
    }
  };

  map_sort_bundles = function(ctx, bundles, recipe, realm, map_sort_bundles_cb) {
    var resolve_all_deps, resolve_sub_deps, sort_bundles;
    resolve_sub_deps = function(found_modules, resolve_sub_deps_cb) {
      var args, d, first_level_deps, m;
      first_level_deps = add.apply(null, (function() {
        var _results;
        _results = [];
        for (m in found_modules) {
          d = found_modules[m];
          _results.push(d.deps);
        }
        return _results;
      })());
      args = {
        modules: first_level_deps,
        app_root: ctx.own_args.app_root,
        recipe_deps: recipe.deps,
        ctx: ctx
      };
      return resolve_deps(args, function(err, found_modules_second_level) {
        var deps, module;
        for (module in found_modules_second_level) {
          deps = found_modules_second_level[module];
          if (!(__indexOf.call(found_modules, module) >= 0)) {
            found_modules[module] = deps;
          }
        }
        return resolve_sub_deps_cb(CB_SUCCESS, found_modules);
      });
    };
    resolve_all_deps = function(args, resolve_all_deps_cb) {
      return async.waterfall(add([
        (function(args) {
          return function(cb) {
            return resolve_deps(args, cb);
          };
        })(args)
      ], [1, 2, 3, 4, 5].map(function() {
        return resolve_sub_deps;
      })), resolve_all_deps_cb);
    };
    sort_bundles = function(bundle, sort_bundles_cb) {
      var args;
      args = {
        modules: bundle.modules,
        app_root: ctx.own_args.app_root,
        recipe_deps: recipe.deps,
        ctx: ctx
      };
      return resolve_all_deps(args, function(err, modules) {
        var sorted_modules;
        sorted_modules = toposort({
          realm: realm,
          bundle: bundle
        }, modules, ctx);
        return sort_bundles_cb(CB_SUCCESS, sorted_modules);
      });
    };
    return async.map(bundles, sort_bundles, map_sort_bundles_cb);
  };

  filter_duplicates = function(bundles_sorted_list) {
    var filtered_bundles, _i, _ref5, _results;
    filtered_bundles = (function() {
      _results = [];
      for (var _i = 0, _ref5 = bundles_sorted_list.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; 0 <= _ref5 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      var m, prev_bundles, prev_bundles_names, _i, _len, _ref5, _ref6, _results;
      prev_bundles = (add.apply(null, bundles_sorted_list.slice(0, i))) || [];
      prev_bundles_names = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = prev_bundles.length; _i < _len; _i++) {
          m = prev_bundles[_i];
          _results.push(m.name);
        }
        return _results;
      })();
      _ref5 = bundles_sorted_list[i];
      _results = [];
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        m = _ref5[_i];
        if (!(_ref6 = m.name, __indexOf.call(prev_bundles_names, _ref6) >= 0)) {
          _results.push(m);
        }
      }
      return _results;
    });
    return filtered_bundles;
  };

  build_bundles = function(ctx, bundles, recipe, build_deps, realm, filtered_bundles, build_bundles_cb) {
    var build_bundle_wrapper, build_bundles_done, _i, _ref5, _results;
    build_bundle_wrapper = function(index, build_bundle_wrapper_cb) {
      var build_bundle_cb, build_deps_modules_names, filtered_modules_names, force_bundle, force_compile, is_bundle_recipe_changed, is_recipe_bundle_changed, m, maybe_minify;
      maybe_minify = get_opt('minify', bundles[index].opts, recipe.opts);
      force_compile = get_opt('force_compile', bundles[index].opts, recipe.opts);
      force_bundle = get_opt('force_bundle', bundles[index].opts, recipe.opts);
      build_bundle_cb = function(err, res) {
        var args, bundle_name, mod_status, not_changed, post_build_bundle_cb;
        if (err) {
          return build_bundle_wrapper_cb(err, res);
        } else {
          realm = res[0], bundle_name = res[1], not_changed = res[2];
          mod_status = {};
          mod_status[realm] = {};
          mod_status[realm][bundle_name] = not_changed;
          post_build_bundle_cb = function() {
            return build_bundle_wrapper_cb(CB_SUCCESS, {
              name: bundles[index].name,
              modules: filtered_bundles[index],
              not_changed: mod_status[realm][bundles[index].name]
            });
          };
          if (maybe_minify) {
            args = {
              global: {
                debug: true
              },
              minify: {
                src: path.join(get_tmp_build_dir(ctx.own_args.build_root), realm),
                pattern: bundles[index].name
              }
            };
            return run_target('minify', args, ctx, post_build_bundle_cb);
          } else {
            return post_build_bundle_cb();
          }
        }
      };
      try {
        if (build_deps && (build_deps[realm][bundles[index].name] != null)) {
          build_deps_modules_names = (function() {
            var _i, _len, _ref5, _results;
            _ref5 = build_deps[realm][bundles[index].name];
            _results = [];
            for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
              m = _ref5[_i];
              _results.push(m.name);
            }
            return _results;
          })();
          filtered_modules_names = (function() {
            var _i, _len, _ref5, _results;
            _ref5 = filtered_bundles[index];
            _results = [];
            for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
              m = _ref5[_i];
              _results.push(m.name);
            }
            return _results;
          })();
          is_recipe_bundle_changed = !(build_deps_modules_names.map(function(m) {
            return __indexOf.call(filtered_modules_names, m) >= 0;
          }).reduce(function(a, b) {
            return a && b;
          }));
          is_bundle_recipe_changed = !(filtered_modules_names.map(function(m) {
            return __indexOf.call(build_deps_modules_names, m) >= 0;
          }).reduce(function(a, b) {
            return a && b;
          }));
        } else {
          force_compile = true;
        }
      } catch (ex) {
        force_compile = true;
      }
      return build_bundle({
        realm: realm,
        bundle_name: bundles[index].name,
        bundle_opts: bundles[index].opts,
        force_compile: force_compile || (is_recipe_bundle_changed || is_bundle_recipe_changed),
        force_bundle: force_bundle,
        sorted_modules_list: filtered_bundles[index],
        build_root: get_tmp_build_dir(ctx.own_args.build_root),
        cache_root: get_modules_cache_dir(ctx.own_args.app_root),
        build_bundle_cb: build_bundle_cb,
        recipe: recipe,
        ctx: ctx
      });
    };
    build_bundles_done = function(err, filtered_bundles_list) {
      var no_changes, result;
      if (err) {
        return build_bundles_cb(err);
      } else {
        result = {};
        no_changes = (filtered_bundles_list.map(function(_arg) {
          var modules, name, not_changed;
          name = _arg.name, modules = _arg.modules, not_changed = _arg.not_changed;
          result[name] = modules;
          return not_changed;
        })).reduce(function(a, b) {
          return a && b;
        });
        return build_bundles_cb(CB_SUCCESS, {
          name: realm,
          bundles: result,
          not_changed: no_changes
        });
      }
    };
    return async.map((function() {
      _results = [];
      for (var _i = 0, _ref5 = filtered_bundles.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; 0 <= _ref5 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), build_bundle_wrapper, build_bundles_done);
  };

  process_realms = function(ctx, recipe, build_deps, cb) {
    var done_processing_realms, k, process_realm, v;
    show_realms(ctx, recipe);
    process_realm = function(_arg, process_realm_cb) {
      var bundles, realm;
      realm = _arg[0], bundles = _arg[1];
      return map_sort_bundles(ctx, bundles, recipe, realm, function(err, bundles_sorted_list) {
        var filtered_bundles;
        filtered_bundles = filter_duplicates(bundles_sorted_list);
        return build_bundles(ctx, bundles, recipe, build_deps, realm, filtered_bundles, function(err, sorted_realms) {
          return process_realm_cb(err, sorted_realms);
        });
      });
    };
    done_processing_realms = function(err, sorted_realms) {
      var fn, no_changes, result;
      if (err) {
        return cb(err, sorted_realms);
      } else {
        result = {};
        no_changes = (sorted_realms.map(function(_arg) {
          var bundles, name, not_changed;
          name = _arg.name, bundles = _arg.bundles, not_changed = _arg.not_changed;
          result[name] = bundles;
          return not_changed;
        })).reduce(function(a, b) {
          return a && b;
        });
        if (no_changes) {
          return cb(CB_SUCCESS);
        } else {
          if (ctx.own_args.just_compile) {
            return cb(CB_SUCCESS);
          } else {
            fn = path.resolve(get_tmp_build_dir(ctx.own_args.build_root), BUILD_DEPS_FN);
            return write_build_deps_file(ctx, fn, result, cb);
          }
        }
      }
    };
    return async.map((function() {
      var _ref5, _results;
      _ref5 = recipe.realms;
      _results = [];
      for (k in _ref5) {
        v = _ref5[k];
        _results.push([k, v]);
      }
      return _results;
    })(), process_realm, done_processing_realms);
  };

  build = function(ctx, build_cb) {
    var a, b, build_deps;
    try {
      build_deps = JSON.parse(fs.readFileSync(path.resolve(get_tmp_build_dir(ctx.own_args.build_root), BUILD_DEPS_FN)));
    } catch (e) {
      ctx.fb.shout("Build deps json is not found - forcing compile");
    }
    a = (function(ctx) {
      return function(val, cb) {
        return get_ctx_recipe(ctx, val, cb);
      };
    })(ctx);
    b = (function(ctx) {
      return function(val, cb) {
        return process_realms(ctx, val, build_deps, cb);
      };
    })(ctx);
    return (compose.async(check_ctx, a, b))(ctx, build_cb);
  };

  module.exports = make_target("build", build, help);

}).call(this);
