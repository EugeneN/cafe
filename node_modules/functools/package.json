{
  "name": "functools",
  "version": "1.4.0",
  "description": "A minimal library of functional operations",
  "author": {
    "name": "Azer Koculu",
    "email": "azer@kodfabrik.com"
  },
  "keywords": [
    "functional",
    "fp"
  ],
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/functools",
  "repository": {
    "type": "git",
    "url": "http://github.com/azer/functools.git"
  },
  "devDependencies": {
    "lowkick": "0.x",
    "highkick": "1.x"
  },
  "scripts": {
    "test": "./node_modules/.bin/highkick test/main.js"
  },
  "readme": "functools is a JavaScript library for functional programming.\n\nInspired by: Common Lisp, Clojure and Python.\nTested on: Chrome, IE6 and Node. (See *test/results.json* for details)\n\n# SYNOPSIS\n\nFunction Composition:\n\n```javascript\nvar compose = require(\"functools\").compose;\n\ncompose(select, update, prettify, display)(\"body .messages\");\n```\n\nAsync Function Compositon:\n\n```javascript\n\nfunction findFiles(path, callback){  ... }\nfunction readContents(files, callback){ ... }\nfunction upload(files, callback){}\n\ncompose.async(findFiles, readContents, upload)('~/messages', function(error, uploadResult){\n  ...\n});\n```\n\nAsync Juxtaposition:\n\n```javascript\nfunction turkish(word, callback){ /* some magic here */ }\nfunction french(word, callback){ /* some magic here */ }\nfunction polish(word, callback){ /* some magic here */ }\n\njuxt.async({ 'tr': turkish, 'fr': french, 'pl': polish })(\"hello\", function(error,  results){\n  assert.equal(results.tr, \"merhaba\");\n  assert.equal(results.fr, \"bonjour\");\n  assert.equal(results.pl, \"cześć\");\n});\n```\n\nCurrying:\n\n```javascript\nvar fn = require(\"functools\");\n\nvar pickEvens = fn.curry(fn.filter)(function(num){ return num%2==0 });\n\npickEvens([3,1,4]) // returns [4]\npickEvens([1,5,9,2,6,5]) // returns [2,6]\n```\n\n\n# INSTALL\n\n```bash\n$ npm install functools\n```\n\nor\n\n```bash\n$ wget https://raw.github.com/azer/functools/master/lib/functools.js\n```\n\n# WHAT'S NEW?\n\n06.09.2012\n* each.async\n* memoize\n* memoize.async\n\n06.08.2012\n* IE6, IE7 and IE8 bugfixes\n* better testing\n\n# DOCUMENTATION\n\n* [compose](#compose)\n* [compose.async](#compose.async)\n* [curry](#curry)\n* [each](#each)\n* [each.async](#each.async)\n* [filter](#filter)\n* [filter.async](#filter.async)\n* [juxt](#juxt)\n* [juxt.async](#juxt.async)\n* [map](#map)\n* [map.async](#map.async)\n* [memoize](#memoize)\n* [memoize.async](#memoize.async)\n* [partial](#partial)\n* [reduce](#reduce)\n* [reduce.async](#reduce.async)\n\n<a name=\"compose\" />\n## compose(*functions ...*)(*value*)\n\nCombine *functions* in a new one, passing the result of each function to next\none, from left to right.\n\n```javascript\nfunction cube(x){ return x*x*x };\n\ncompose(Math.sqrt,cube)(4); // returns 8\n```\n\n<a name=\"compose.async\" />\n## compose.async(*functions ...*)(*value*,*callback*)\n\nAsynchronous, continuation passing based version of compose function. Requires\nspecified functions to call a callback function, passing an error object (if\nthere is one) and the result to be carried.\n\n```javascript\nfunction receiveMessage(message, callback){ ... callback(); }\nfunction findRelatedUser(message, callback){ ... callback(null, user, message); }\nfunction transmitMessage(user, message){ ... callback(); }\n\nvar messageTransmission = compose.async(receiveMessage, findRelatedUser, transmitMessage);\n\nmessageTransmission({ msg:\"Hello !\", 'user': 3 }, function(error, result){\n  ...\n})\n\n```\n<a name=\"curry\" />\n## curry(*function*, *args ...*)\n\nTransform multiple-argument *function* into a chain of functions that return each other until all arguments are gathered.\n\n```javascript\nfunction sum(x,y){ return x+y; }\n\nvar add3 = curry(sum, 3);\n\nadd3(14); // returns 17\nadd3(20); // returns 23\n```\n\n<a name=\"each\" />\n## each(*function*,*iterable*)\n\nCall *function* once for each element in *iterable*.\n\n```javascript\neach(function(el,ind,list){ console.assert( el == list[ind] ); }, [3, 1, 4]);\n```\n\n<a name=\"each.async\" />\n## each.async(*function*,*iterable*,*callback*)\n\nCall async *function* once for each element in *iterable*, and *callback* after iteration.\n\n```javascript\n\n> function uploadFile(filename, callback){\n  console.log('Uploading ', filename);\n  callback();\n}\n\n> each.async(uploadFile, [ '/docs/intro', '/docs/body', '/docs/outro' ], function(error){\n\n  if(error){\n    console.log('Failed to upload files');\n    throw error;\n  }\n\n  console.log('All files has been uploaded successfully');\n\n});\n\n> Uploading /docs/intro\nUploading /docs/body\nUploading /docs/outro\nAll files has been uploaded successfully\n```\n\n<a name=\"filter\" />\n## filter(*function*,*iterable*)\n\nConstruct a new array from those elements of *iterable* for which *function* returns true.\n\n```javascript\nfilter(function(el,ind,list){ return el%2==0 }, [3, 1, 4]); // returns [4]\n```\n\n<a name=\"filter.async\" />\n## filter.async(*function*,*iterable*, *callback*)\n\nCall async *function* once for each element in *iterable*, receiving a boolean\nparameter, and construct a new array of all the values for which *function*\nproduces *true*\n\n```javascript\n\nvar users = [ 3, 5, 8, 13, 21 ]; // only user#3 and user#8 have permission in this example\n\nfunction hasPermission(userId, callback){ ... callback(/* true or false */); }\n\nfilter.async(hasPermission, [3, 1, 4], function(permittedUsers){\n  assert.equal(permittedUsers.length, /* ? */);\n});\n\n```\n\n<a name=\"juxt\" />\n## juxt(*functions ...*)\n\nTake a set of functions, return a function that is the juxtaposition of those\nfunctions. The returned function takes a variable number of arguments and\nreturns a list containing the result of applying each fn to the arguments.\n\n```javascript\nfunction inc1(n){ return n+1 };\nfunction inc2(n){ return n+2 };\nfunction inc3(n){ return n+3 };\n\njuxt(inc1, inc2, inc3)(314); // returns [315,316,317]\n```\n\n<a name=\"juxt.async\" />\n## juxt.async(*functions ...*)\n\nAsync implementation of *juxt*.\n\n```javascript\nfunction turkish(word, callback){ /* some magic here */ }\nfunction french(word, callback){ /* some magic here */ }\nfunction polish(word, callback){ /* some magic here */ }\n\njuxt.async(turkish, french, polish)(\"hello\", function(error,  results){\n  assert.equal(results[0], \"merhaba\");\n  assert.equal(results[1], \"bonjour\");\n  assert.equal(results[2], \"cześć\");\n});\n```\n\n<a name=\"map\" />\n## map(*function*,*iterable*)\n\nInvoke *function* once for each element of *iterable*. Creates a new iterable\ncontaining the values returned by the function.\n\n```javascript\n\nfunction square(n){\n  return n*n;\n}\n\nmap(square, [3,1,4,1,5,9]); // returns [9,1,16,1,25,81]\n```\n\nObjects can be passed as well;\n\n```javascript\nvar dict = { 'en':'hello', 'tr': 'merhaba', 'fr':'bonjour' };\n\nfunction capitalize(str){\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nmap(capitalize, dict); // returns { 'en':'Hello', 'tr':'Merhaba', 'fr':'Bonjour' }\n```\n\n<a name=\"map.async\" />\n## map.async(*function*,*iterable*, *callback*)\n\nApply async *function* to every item of *iterable*, receiving a callback\nfunction which takes error (if there is) and replacement parameters.\n\n```javascript\nfunction readFile(id, callback){ ... callback(undefined, data); }\n\nmap.async(readFile, ['./foo/bar', './foo/qux', './corge'], function(error, files){\n  if(error) throw error;\n\n  console.log(files[0]); // will put the content of ./foo/bar\n});\n```\n\n<a name=\"memoize\" />\n## memoize(*function*,*hasher*)\n\nReturn a memoized version of *function*. *hasher* is optional.\n\n```javascript\n> function myfunc(n){\n    console.log(\"doing some work\");\n    return n + 10;\n}\n\n> var myfuncMemo = memoize(myfunc);\n> myfuncMemo(1);\n\"doing some work\"\n11\n> myfuncMemo(1);\n11\n> myfuncMemo(20);\n\"doing some work\"\n30\n> myfuncMemo(20);\n30\n```\n\n<a name=\"memoize.async\" />\n## memoize.async(*function*, *hasher*)\n\nMemoize given async *function* if it doesn't produce any error.\n\n```javascript\n> function readFile(){ console.log('doing some work'); ... callback(undefined, buffer); }\n\n> var readFileMemo = memoize.async(readFile);\n\n> readFileMemo('/docs/readme', function(error, content){\n    console.log(content);\n});\n\"doing some work\"\n\n> \"This is the Readme file\"\n\n> readFileMemo('/docs/readme', function(error, content){\n    console.log(content);\n});\n\"This is the Readme file\"\n```\n\n<a name=\"partial\" />\n## partial(*function*,*initial arguments*,*context *)\n\nReturn a new function which will call *function* with the gathered arguments.\n\n```javascript\nfunction testPartial(){\n  var args = reduce(function(x,y){ x+\", \"+y },arguments);\n\n  console.log(\"this:\",this);\n  console.log(\"args:\",args);\n}\n\npartial(testPartial, [3,14], 3.14159)(1,5,9);\n```\n\nThe example code above will output:\n```\nthis: 3.14159\nargs: 3,14,1,5,9\n```\n\n<a name=\"reduce />\n## reduce(*function*,*iterable*)\n\nApply *function* cumulatively to the items of *iterable*,  as to reduce the\n*iterable* to a single value\n\n```javascript\nreduce(function(x,y){ return x*y }, [3,1,4]); // returns 12\n```\n\n<a name=\"reduce.async\" />\n## reduce.async(*function*,*iterable*, *callback*)\n\nAsync implementation of *reduce*.\n\n```javascript\n\nvar users = [2, 3, 5, 8, 13];\n\nfunction usernames(accum, userId){ ... callback(undefined, accum + ', ' + username); }\n\nreduce.async(usernames, users, function(error, result){\n  if(error) throw error;\n\n  console.log(result); // foo, bar, qux ...\n});\n\n```\n\n# Testing\n\n## On NodeJS:\n\n```\n$ npm test\n```\n\n## On Browsers\n\nRun `make test` command to publish the tests on `localhost:1314`. Visit the URL using the browser on which you want to run the tests. Stop the server (Ctrl+C) when you're done with testing.\n\nTo see the summary of results;\n\n```\n$ make test do=verify\nNot Tested: firefox, ie8, ie7\nPassed: ie6, webkit\n\nRevision: 1.3.0\nResults Source: test/results.json\nConfig: test/config.json\n```\n\n# SEE ALSO\n- [Functional Programming - Eloquent JavaScript](http://eloquentjavascript.net/chapter6.html)\n",
  "readmeFilename": "README.md",
  "_id": "functools@1.4.0",
  "_from": "functools@*"
}
